# Introduction
Header-only implementation of an N-dimensional array for modern C++.


## Overview
This library adopts an abstract notion of an array. An array is any mapping from a space of N-dimensional indexes `(i, j, ...)` to some type of value, and which defines a rectangular region (the shape) containing the valid indexes:

    `array: (index => value, shape)`

This means that the mapped values may be generated in a variety of ways - either by looking them up in a memory buffer (as in a conventional array), or by calling a function with the index as a parameter.

An array is a class template parameterized around a `provider` type. Operations applied to the array (such as slicing, reshaping, or mapping the underlying values) generate a provider of a new type, and return an array holding that new provider. This enables a highly optimized and memory-efficient code to be generated by the compiler. Arrays can be converted to memory-backed arrays at any stage in an algorithm. This caches their values and collapses the type hierarchy.


## Immutability
Arrays are immutable, meaning that you manipulate them by applying transformations to existing arrays to generate new ones. But they are also light-weight objects that incur essentially zero overhead when passed by value. This is because memory-backed arrays only hold a `std::shared_ptr` to an immutable memory buffer, while operated-on arrays only hold lightweight function objects. Transformed arrays do not allocate new memory buffers, and do not perform any calculations until they are indexed, or converted to a memory-backed array. Such lazy evaluation trades compile time overhead in exchange for runtime performace (the compiler sees the whole type hierarchy and can scrunch it down to perform optimizations) and reduced memory footprint.

There is one exception to immutability, a `unique_array`, which is memory-backed and read/write, so it enables procedural loading of data into a memory-backed array. The `unique_array` owns its data buffer, and is move-constructible but not copy-constructible (following the semantics of `unique_ptr`). After loading data into it, it can be moved to a shared (immutable, copy-constructible) memory-backed array. The fact that mutable arrays cannot be copied ensures that you're not accidentally passing around heavyweight objects by value.


## Quick-start
Create a 10 x 20 array of zero-initialized ints:
```C++
auto A = nd::zeros(10, 20);
```

Add an array of doubles to it:
```C++
auto B = A + nd::ones<double>(10, 20);
```

Get the shape and total number of elements in an array:
```C++
auto shape = A.shape();
auto size = A.size();
```

Create an array as a subset of another:
```C++
auto B = A | nd::select_from(0, 0).to(10, 10).jumping(2, 2); // B.shape() == {5, 5}
```

Create an array by substituting a region with values from another array:
```C++
auto B = A | nd::replace_from(0, 0).to(10, 5).with(nd::zeros(10, 5));
```

Reduce the dimensionality of an array by slicing:
```C++
auto B = A | nd::freeze_axis(0).at_index(2);
```

Transform an array element-wise:
```C++
auto B = A | nd::transform([] (auto x) { return x * x; });
```

Create an array of tuples from arrays of identical shape:
```C++
auto ABC = nd::zip_arrays(A, B, C);
auto a = std::get<0>(ABC(0, 0));
```


## Using the `unique_array`
For most use cases, you should be able to build your arrays procedurally by composing a sequence of operators. However, it's sometimes necessary to modify the memory backing procedurally. This is the purpose of unique array (also called transients in other libraries based on immutable data).

There are two ways to create a unique array: from scratch,

```C++
auto A = nd::unique_array(10, 20);
```

or from an existing array,

```C++
auto A = nd::ones(10, 20).unique();
```

Now, you can load data into the mutable array procedurally,

```C++
for (auto index : A.indexes())
{
    A(index) = index[0] + index[1];
}
```

Your unique array has data in it, but you can't really do anything with it. Remember, it can't be sent it anywhere by value. That includes applying operators to it, since the operators use value (rather than reference) semantics. You need to move the array to a shared one:

```C++
auto B = A.shared();
```

There! Now you have an immutable, memory-backed array with the same data content as `A` had. But be aware... you did just incur a heavy-weight copy. Indeed, if you check, you'll see that

```C++
B.data() != A.data();
```

If you wanted, you could keep calling `A.shared()` to vend out new copies of its data.

__Note__: only memory-backed arrays have a `data` member function. You'd get a compile error if you were to do `(A | select_from(5, 10)).data()`.

Anyway, in many cases you don't need the unique array to generate more than a single immutable copy. So, you can use the move operator to avoid the copy,

```C++
auto B = std::move(A).shared();
```

Here, ownership of the data buffer is transferred to `B`, leaving `A` in a "valid but useless" state. You could reassign it to another unique array if you wanted to.