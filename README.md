# Introduction
Header-only implementation of an N-dimensional array for modern C++.


## Overview
This library adopts an abstract notion of an array: an array is something that defines an N-dimensional index space (a _shape_), and a mapping from that space to values,

    `arrays := (shape, index => value)`

The mapped values may be generated however you want - either by looking them up in a memory buffer (as in a conventional array), or by calling a function with the index as a parameter.

You might regard the data structures and algorithms provided here as an N-dimensional counterpart of [C++ ranges](https://en.cppreference.com/w/cpp/ranges), as implemented by e.g. the [range-v3](https://github.com/ericniebler/range-v3) project. Such *functional programming* approaches to writing C++ code are gaining wider attention, and becoming more feasible as the language evolves.


## Implementation
An array is a class template parameterized around a _provider_. Operations applied to the array (such as selecting, replacing, or transforming the underlying values) return an array with a new provider. This enables highly optimized and memory-efficient code to be generated by the compiler, but does so at the expense of generating a large number of types, which can become deeply nested. Arrays can be converted to memory-backed arrays at any stage in an algorithm; doing so caches their values and collapses the type hierarchy.


## Immutability
Arrays are immutable, meaning that you manipulate them by applying transformations to existing arrays to generate new ones. But they are also light-weight objects that incur essentially zero overhead when passed by value. This is because memory-backed arrays only hold a `std::shared_ptr` to an immutable memory buffer, while operated-on arrays only hold lightweight function objects. They do not allocate new memory buffers, and do not perform any calculations until they are indexed, or converted to a memory-backed array. Such lazy evaluation trades compile time overhead in exchange for runtime performace (the compiler sees the whole type hierarchy and can scrunch it down to perform optimizations) and reduced memory footprint.

There is one exception to immutability, a `unique_array`, which is memory-backed and read/write, so it enables procedural loading of data into a memory-backed array. The `unique_array` owns its data buffer, and is move-constructible but not copy-constructible (following the semantics of `unique_ptr`). After loading data into it, it can be moved to a shared (immutable, copy-constructible) memory-backed array. The fact that mutable arrays cannot be copied ensures that you're not accidentally passing around heavyweight objects by value.


## Quick-start
Create a 10 x 20 array of zero-initialized ints:
```C++
auto A = nd::zeros(10, 20);
```

Add an array of doubles to it:
```C++
auto B = A + nd::ones<double>(10, 20);
```

Get the shape and total number of elements in an array:
```C++
auto shape = A.shape();
auto size = A.size();
```

Create an array as a subset of another:
```C++
auto B = A | nd::select_from(0, 0).to(10, 10).jumping(2, 2); // B.shape() == {5, 5}
```

Create an array by substituting a region with values from another array:
```C++
auto B = A | nd::replace_from(0, 0).to(10, 5).with(nd::zeros(10, 5));
```

Reduce the dimensionality of an array by slicing:
```C++
auto B = A | nd::freeze_axis(0).at_index(2);
```

Transform an array element-wise:
```C++
auto B = A | nd::transform([] (auto x) { return x * x; });
```

Create an array of tuples from arrays of identical shape:
```C++
auto ABC = nd::zip_arrays(A, B, C);
auto a = std::get<0>(ABC(0, 0));
```


## Using the `unique_array`
For most use cases, you should be able to build your arrays procedurally by composing a sequence of operators. However, it's sometimes necessary to modify the memory backing procedurally. This is the purpose of unique array (also called transients in other libraries based on immutable data).

There are two ways to create a unique array: from scratch,

```C++
auto A = nd::unique_array(10, 20);
```

or from an existing array,

```C++
auto A = nd::ones(10, 20).unique();
```

Now, you can load data into the mutable array procedurally,

```C++
for (auto index : A.indexes())
{
    A(index) = index[0] + index[1];
}
```

Your unique array has data in it, but you can't really do anything with it. Remember, it can't be sent it anywhere by value. That includes applying operators to it, since the operators use value (rather than reference) semantics. You need to move the array to a shared one:

```C++
auto B = A.shared();
```

There! Now you have an immutable, memory-backed array with the same data content as `A` had. But be aware... you did just incur a heavy-weight copy. Indeed, if you check, you'll see that

```C++
B.data() != A.data();
```

If you wanted, you could keep calling `A.shared()` to vend out new copies of its data.

__Note__: only memory-backed arrays have a `data` member function. You'd get a compile error if you were to do `(A | select_from(5, 10)).data()`.

Anyway, in many cases you don't need the unique array to generate more than a single immutable copy. So, you can use the move operator to avoid the copy,

```C++
auto B = std::move(A).shared();
```

Here, ownership of the data buffer is transferred to `B`, leaving `A` in a "valid but useless" state. You could reassign it to another unique array if you wanted to.
